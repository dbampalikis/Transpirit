/* * To change this template, choose Tools | Templates * and open the template in the editor. */package Engine;import java.io.*;import javax.sound.sampled.*;import java.lang.*;import java.net.URL;/** * * @author obscure */public class SimpleSoundPlayer implements Runnable{        private AudioFormat format;    private byte[] samples;    private Thread thread;    /**    Opens a sound from a file.    */    public SimpleSoundPlayer(String filename) {        try {        // open the audio input stream            AudioInputStream stream = AudioSystem.getAudioInputStream(_LoadSound(filename));            //System.out.println(_LoadSound(filename));            format = stream.getFormat();            // get the audio samples            samples = getSamples(stream);            // create a new thread and start it -> calls function run            //thread = new Thread(this);            //thread.start();        }        catch (UnsupportedAudioFileException ex) {            ex.printStackTrace();        }        catch (IOException ex) {            ex.printStackTrace();        }    }        // Local Path resolution method for jar    // To use loadSound method in EngineCore we need to pass EngineCore object en    // Which is bit memory consuming    public URL _LoadSound(String soundName){        return SimpleSoundPlayer.this.getClass().getClassLoader().getResource(soundName);    }        public void stop1(){        thread.stop();    }    //Gets the samples of this sound as a byte array.    public byte[] getSamples() {        return samples;    }        //Gets the samples from an AudioInputStream as an array    //of bytes.        private byte[] getSamples(AudioInputStream audioStream) {        //get the number of bytes to read        int length = (int)(audioStream.getFrameLength() * format.getFrameSize());        //read the entire stream        byte[] samples = new byte[length];        DataInputStream is = new DataInputStream(audioStream);        try {            is.readFully(samples);        }        catch (IOException ex) {            ex.printStackTrace();        }        // return the samples        return samples;    }    //Plays a stream. This method blocks (doesn't return) until    //the sound is finished playing.    public void play(InputStream source) {        // use a short, 100ms (1/10th sec) buffer for real-time        // change to the sound stream        int bufferSize = format.getFrameSize() * Math.round(format.getSampleRate() / 10);        byte[] buffer = new byte[bufferSize];        // create a line to play to        SourceDataLine line;        try {            DataLine.Info info = new DataLine.Info(SourceDataLine.class, format);            line = (SourceDataLine)AudioSystem.getLine(info);            line.open(format, bufferSize);        }        catch (LineUnavailableException ex) {            ex.printStackTrace();        return;        }        //start the line        line.start();        //copy data to the line        try {            int numBytesRead = 0;            while (numBytesRead != -1) {                numBytesRead = source.read(buffer, 0, buffer.length);                if (numBytesRead != -1) {                    line.write(buffer, 0, numBytesRead);                }            }        }        catch (IOException ex) {            ex.printStackTrace();        }        //wait until all data is played        line.drain();        //close the line        line.close();        }    @Override    public void run() {        // create the stream to play        ByteArrayInputStream s = new LoopingByteInputStream(this.getSamples());        // play the sound        this.play(s);    }}